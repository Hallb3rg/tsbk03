// Demo of heavily simplified sprite engine
// by Ingemar Ragnemalm 2009
// used as base for lab 4 in TSBK03.
// OpenGL 3 conversion 2013.

#ifdef __APPLE__
	#include <OpenGL/gl3.h>
	#include "MicroGlut.h"
	// uses framework Cocoa
#else
	#include <GL/gl.h>
	#include "MicroGlut.h"
#endif

#include <stdlib.h>
#include "LoadTGA.h"
#include "SpriteLight.h"
#include "GL_utilities.h"
#include <math.h>

// Lgg till egna globaler hr efter behov.

float cohesion_constant = 0.0;
float separation_constant = 0.0; //3.0/300.0;
float align_constant = 0.0;
float separation_dist_sqr = 10000.0;
float group_dist_sqr = 40000.0; // squared distance for cohesion

const float max_speed = 2.0;

float avoidanceCalc(float input);

void SpriteBehavior() // Din kod!
{
// Lgg till din labbkod hr. Det gr bra att ndra var som helst i
// koden i vrigt, men mycket kan samlas hr. Du kan utg frn den
// globala listroten, gSpriteRoot, fr att kontrollera alla sprites
// hastigheter och positioner, eller arbeta frn egna globaler.
	SpritePtr sp, spC;
    int tot_sprites;
    float tot_h, tot_v, current_sheep_pos_v, current_sheep_pos_h, distance, group_h, group_v;
    float avoid_h, avoid_v, group_length, normal_speed;

    /*Cohesion+separation*/ 
    
    sp = gSpriteRoot;
   

	do // for each sheep
	{
        current_sheep_pos_v = sp->position.v;
        current_sheep_pos_h = sp->position.h;
        spC = gSpriteRoot;
        tot_h = 0.0;
        tot_v = 0.0; 
        group_h = 0.0; 
        group_v = 0.0;
        avoid_h = 0.0;
        avoid_v = 0.0;
        tot_sprites = 0.0;
        while (spC != NULL) {
            distance = pow(current_sheep_pos_v - spC->position.v,2.0) + 
                pow(current_sheep_pos_h - spC->position.h,2.0);

            //printf("distance = %f\n", distance);

            if (distance < group_dist_sqr) {           
                tot_h += spC->position.h;
                tot_v += spC->position.v;

                tot_sprites++; 
            }


            if (distance < separation_dist_sqr && distance > 0) {
                avoid_h += avoidanceCalc(sp->position.h - spC->position.h);
                avoid_v += avoidanceCalc(sp->position.v - spC->position.v);

            }


            /*if (distance < separation_dist_sqr) {// && distance > 20) {           
                sp->speed.h += avoidanceCalc(sp->position.h - spC->position.h); 
                sp->speed.v += avoidanceCalc(sp->position.v - spC->position.v); 
            } */
            spC = spC->next; 
        }
       
        //printf("number of sheep that are close are: %i\n", tot_sprites);

        if (tot_sprites > 0) {
            group_h = tot_h/tot_sprites;
            group_v = tot_v/tot_sprites;

            //group_length = sqrt(pow(group_h,2.0) + pow(group_v, 2.0));

            
            avoid_h = avoid_h/tot_sprites;
            avoid_v = avoid_v/tot_sprites;

            //printf("group coordinates are (%f,%f)\n",group_h, group_v);
            //printf("sheep raw h addition = %f\n", (group_h - current_sheep_pos_h));
            //printf("sheep modified h addition = %f\n\n", (group_h - current_sheep_pos_h)*cohesion_constant);

            sp->speed.h += (group_h - current_sheep_pos_h)*cohesion_constant; //group_length;
            //printf("avoid_h is: %f\n", avoid_h);
            sp->speed.h += avoid_h * separation_constant;
    
            sp->speed.v += (group_v - current_sheep_pos_v)*cohesion_constant; //group_length;
            sp->speed.v += avoid_h * separation_constant;

        }

        
        /*
        normal_speed = sqrt(pow(sp->speed.h, 2.0) + pow(sp->speed.v,2.0));

        sp->speed.h = sp->speed.h/normal_speed * max_speed;

        sp->speed.v = sp->speed.v/normal_speed * max_speed;

        */

        /*
        
        
        const float max_speed = 2.0;

        if (sp->speed.h > max_speed) {
            sp->speed.h = max_speed;
        } else if (sp->speed.h < -max_speed) {
            sp->speed.h = -max_speed;
        }
         
        if (sp->speed.v > max_speed) {
            sp->speed.v = max_speed;
        } else if (sp->speed.v < -max_speed) {
            sp->speed.v = -max_speed;
        }

        */
        


		sp = sp->next;
	} while (sp != NULL);
}


float avoidanceCalc(float input) {

    //return ((input > 0.0) - (input < 0.0))  / (pow(input,2.0));  
    return input;

    //return 0.0;
}


// Drawing routine
void Display()
{
	SpritePtr sp;
	
	glClearColor(0, 0, 0.2, 1);
	glClear(GL_COLOR_BUFFER_BIT+GL_DEPTH_BUFFER_BIT);
	glEnable(GL_TEXTURE_2D);
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	
	DrawBackground();
	
	SpriteBehavior(); // Din kod!
	
// Loop though all sprites. (Several loops in real engine.)
	sp = gSpriteRoot;
	do
	{
		HandleSprite(sp); // Callback in a real engine
		DrawSprite(sp);
		sp = sp->next;
	} while (sp != NULL);
	
	glutSwapBuffers();
}

void Reshape(int h, int v)
{
	glViewport(0, 0, h, v);
	gWidth = h;
	gHeight = v;
}

void Timer(int value)
{
	glutTimerFunc(20, Timer, 0);
	glutPostRedisplay();
}

// Example of user controllable parameter
float someValue = 0.0;

void Key(unsigned char key,
         __attribute__((unused)) int x,
         __attribute__((unused)) int y)
{
  switch (key)
  {

float vseparation_dist_sqr = 10000.0;
//float group_dist_sqr = 40000.0; // squared distance




    case 't':
    	separation_dist_sqr  += 100;
    	printf("separation_dist_sqr  = %f\n", separation_dist_sqr);
    	break;
    case 'g':
    	separation_dist_sqr  -= 100;
    	printf("separation_dist_sqr  = %f\n", separation_dist_sqr);
        break;
    case 'r':
    	group_dist_sqr += 100;
    	printf("group_dist_sqr = %f\n", group_dist_sqr);
    	break;
    case 'f':
        group_dist_sqr -= 100;
    	printf("group_dist_sqr = %f\n", group_dist_sqr);
    	break;


    case 'q':
    	cohesion_constant += 0.001;
    	printf("cohesion_constant = %f\n", cohesion_constant);
    	break;
    case 'a':
    	cohesion_constant -= 0.001;
    	printf("cohesion_constant = %f\n", cohesion_constant);
    	break;
    case 'w':
    	separation_constant += 0.01;
    	printf("separation_constant = %f\n", separation_constant);
    	break;
    case 's':
    	separation_constant -= 0.01;
    	printf("separation_constant = %f\n", separation_constant);
    	break;
    case 'e':
    	align_constant += 0.01;
    	printf("align_constant = %f\n", align_constant);
    	break;
    case 'd':
    	align_constant -= 0.01;
    	printf("align_constant = %f\n", align_constant);
    	break;
    case 0x1b:
      exit(0);
  }
}

void Init()
{
	TextureData *sheepFace, *blackFace, *dogFace, *foodFace;
	
	LoadTGATextureSimple("bilder/leaves.tga", &backgroundTexID); // Bakgrund
	
	sheepFace = GetFace("bilder/sheep.tga"); // Ett fr
	blackFace = GetFace("bilder/blackie.tga"); // Ett svart fr
	dogFace = GetFace("bilder/dog.tga"); // En hund
	foodFace = GetFace("bilder/mat.tga"); // Mat
	
	NewSprite(sheepFace, 700, 200, 1, 1.2);
	NewSprite(sheepFace, 200, 500, 1.6, -1);
	NewSprite(sheepFace, 250, 200, -1.8, 0.3);
	NewSprite(sheepFace, 50, 550, 1, 1);
	NewSprite(sheepFace, 300, 100, 1.5, -0.8);
	NewSprite(sheepFace, 450, 200, -1, 1.7);
	NewSprite(sheepFace, 400, 300, 1, 1.7);
	NewSprite(sheepFace, 300, 50, 1.4, -1);
	NewSprite(sheepFace, 250, 5, -1.2, 1.5);
}

int main(int argc, char **argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE);
	glutInitWindowSize(800, 600);
	glutInitContextVersion(3, 2);
	glutCreateWindow("SpriteLight demo / Flocking");
	
	glutDisplayFunc(Display);
	glutTimerFunc(20, Timer, 0); // Should match the screen synch
	glutReshapeFunc(Reshape);
	glutKeyboardFunc(Key);
	
	InitSpriteLight();
	Init();
	
	glutMainLoop();
	return 0;
}
